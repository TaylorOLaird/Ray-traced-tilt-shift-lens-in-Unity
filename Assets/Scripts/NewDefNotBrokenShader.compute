#pragma kernel CSMain
RWTexture2D<float4> Result;

float4x4 _CameraToWorld;
float4x4 _CameraInverseProjection;
Texture2D<float4> _SkyboxTexture;
SamplerState sampler_SkyboxTexture;

float4 _RedSphere;
float4 _GreenSphere;
float4 _BlueSphere;

float _DefocusRadius;
float _FocusDistance;

static const float PI = 3.14159265f;

struct Ray
{
    float3 origin;
    float3 direction;
};

struct RayHit
{
    float3 position;
    float distance;
    float3 normal;
};

Ray NewRay(float3 origin, float3 direction)
{
    Ray ray;
    ray.origin = origin;
    ray.direction = direction;
    return ray;
}

RayHit NewRayHit()
{
    RayHit hit;
    hit.position = float3(0.0f, 0.0f, 0.0f);
    hit.distance = 1.#INF;
    hit.normal = float3(0.0f, 0.0f, 0.0f);
    return hit;
}

void IntersectSphere(Ray ray, inout RayHit bestHit, float4 sphere)
{
    float3 oc = ray.origin - sphere.xyz;
    float a = dot(ray.direction, ray.direction);
    float b = 2.0f * dot(ray.direction, oc);
    float c = dot(oc, oc) - sphere.w * sphere.w;

    float discriminant = b * b - 4.0f * a * c;
    if (discriminant < 0.0f)
        return;

    float t = (-b - sqrt(discriminant)) / (2.0f * a);
    if (t < 0.0f || t > bestHit.distance)
        return;
    
    bestHit.distance = t;
    bestHit.position = ray.origin + t * ray.direction;
    bestHit.normal = normalize(bestHit.position - sphere.xyz);
}

RayHit Trace(Ray ray)
{
    RayHit bestHit = NewRayHit();
    // IntersectSphere(ray, bestHit, float4(0, 0.0f, 0, 1.0f));
    IntersectSphere(ray, bestHit, _RedSphere);
    IntersectSphere(ray, bestHit, _GreenSphere);
    IntersectSphere(ray, bestHit, _BlueSphere);
    return bestHit;
}

float3 Shade(inout Ray ray, RayHit hit)
{
    if (hit.distance < 1.#INF)
    {
        // Return the normal
        return hit.normal * 0.5f + 0.5f;
    }
    else
    {
        // Sample the skybox and write it
        float theta = acos(ray.direction.y) / -PI;
        float phi = atan2(ray.direction.x, -ray.direction.z) / -PI * 0.5f;
        return _SkyboxTexture.SampleLevel(sampler_SkyboxTexture, float2(phi, theta), 0).xyz;
    }
}

float2 grid_to_disc(float x, float y)
{
    float r, phi;
    float2 translated_coords = float2(0.0f, 0.0f);
    if (x * x > y * y) {
        r = x;
        phi = (PI * y) / (4.0f * x);
    } else {
        r = y;
        phi = (PI / 2.0f) - (PI / 4.0f) * (x / y);
    }

    return float2(r * cos(phi), r * sin(phi));
}

float4 CalculateThinLensRayResult(float2 uv)
{
    float3 result = float3(0.0f, 0.0f, 0.0f);
    // Ray tmpRay;

    // get camera origin and direction from unity scene
    float3 camera_origin = mul(_CameraToWorld, float4(0.0f, 0.0f, 0.0f, 1.0f)).xyz;
    float3 camera_direction = mul(_CameraInverseProjection, float4(uv, 0.0f, 1.0f)).xyz;
    camera_direction = mul(_CameraToWorld, float4(camera_direction, 0.0f)).xyz;
    camera_direction = normalize(camera_direction);

    float3 focal_point = camera_origin + camera_direction * _FocusDistance;

    float samples = 0.0f;

    // loop over a grid of points in the lens plane to shoot rays through the lens
    for (float i = -0.5f * _DefocusRadius; i <= 0.5f * _DefocusRadius; i += 0.1f)
    {
        for (float j = -0.5f * _DefocusRadius; j <= 0.5f * _DefocusRadius; j += 0.1f)
        {
            float3 lens_ray_origin = float3(grid_to_disc(i, j), 0.0f);
            lens_ray_origin += camera_origin;
            float3 lens_ray_direction = normalize(focal_point - lens_ray_origin);

            Ray ray = NewRay(lens_ray_origin, lens_ray_direction);
            RayHit hit = Trace(ray);
            float3 color = Shade(ray, hit);

            result += color;
            samples += 1.0f;
        }
    }

    result /= samples;
    
    return float4(result, 1);
}

Ray CreateCameraRay(float2 uv)
{
    // Transform the camera origin to world space
    float3 origin = mul(_CameraToWorld, float4(0.0f, 0.0f, 0.0f, 1.0f)).xyz;
    
    // Invert the perspective projection of the view-space position
    float3 direction = mul(_CameraInverseProjection, float4(uv, 0.0f, 1.0f)).xyz;

    // Transform the direction from camera to world space and normalize
    direction = mul(_CameraToWorld, float4(direction, 0.0f)).xyz;
    direction = normalize(direction);

    return NewRay(origin, direction);
}

float4 CalculateCameraRayResult(float2 uv)
{
    Ray ray = CreateCameraRay(uv);
    RayHit hit = Trace(ray);
    float3 result = Shade(ray, hit);
    return float4(result, 1);
}

[numthreads(8,8,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    // Get the dimensions of the RenderTexture
    uint width, height;
    Result.GetDimensions(width, height);
    
    // Transform pixel to [-1,1] range
    float2 uv = float2((id.xy + float2(0.5f, 0.5f)) / float2(width, height) * 2.0f - 1.0f);

    // Result[id.xy] = CalculateCameraRayResult(uv);
    Result[id.xy] = CalculateThinLensRayResult(uv);

}