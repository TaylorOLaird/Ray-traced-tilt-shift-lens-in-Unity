#pragma kernel CSMain
RWTexture2D<float4> Result;
Texture2D<float4> _SkyboxTexture;
SamplerState sampler_SkyboxTexture;

int _FrameCount;

// define SPHERES
float3 blue_sphere  = float3(0.75, 0.5, 0.25);
float3 green_sphere = float3(-0.5, -0.25, 0.75);
float3 red_sphere   = float3(0.25, -0.75, -0.5);
static const float PI = 3.14159265f;

// float3 eye          = float3(0.0, 0.0, -2.75);
float3 eye          = float3(0.0, 0.0, -2.75);
float3 look_at      = float3(0.0, 0.0, 0.0);

float epsilon = 0.001;

struct Ray
{
    float3 origin;
    float3 direction;
};

struct RayHit
{
    float3 position;
    float distance;
    float3 normal;
};

RayHit CreateRayHit()
{
    RayHit hit;
    hit.position = float3(0.0f, 0.0f, 0.0f);
    hit.distance = 1.#INF;
    hit.normal = float3(0.0f, 0.0f, 0.0f);
    return hit;
}

void tilt_shift(float2 screen, float2 random, out float3 ray_origin, out float3 ray_direction)
{
    // define CAMERA
    float3 world_middle  = look_at;
    float3 world_focus_a = blue_sphere;
    float3 world_focus_b = green_sphere;
    float3 world_focus_c = red_sphere;
    float sensor_size    = 1.8;
    float f_stop         = 5.0;
    float focal_length   = 1.0;

    float3 gaze  = normalize(look_at - eye);
    float3 right = normalize(cross(gaze, float3(0.0, 1.0, 0.0)));
    float3 up    = cross(gaze, right);

    float3 middle  = float3(dot(right, world_middle - eye), dot(up, world_middle - eye), dot(gaze, world_middle - eye));
    float3 focus_a = float3(dot(right, world_focus_a - eye), dot(up, world_focus_a - eye), dot(gaze, world_focus_a - eye));
    float3 focus_b = float3(dot(right, world_focus_b - eye), dot(up, world_focus_b - eye), dot(gaze, world_focus_b - eye));
    float3 focus_c = float3(dot(right, world_focus_c - eye), dot(up, world_focus_c - eye), dot(gaze, world_focus_c - eye));

    float focal_distance = focus_a.z;

    // n  : normal      A : focus_a
    // t  : tilt        B : focus_b
    // M  : middle      C : focus_c
    // M' : shift

    // Focal plane values (precomputable)
    float3 normal = normalize(cross(focus_b - focus_a, focus_c - focus_a));
    
    // Lens values (precomputable)
    float3 tilt = float3(0.0, 0.0, 0.0);
    if (abs(normal.x) > abs(normal.y)) {
        tilt.x = (focus_a.z - focus_b.z) * focal_length / (focus_a.z * focus_b.x - focus_b.z * focus_a.x + (focus_a.z * focus_b.y - focus_b.z * focus_a.y) * normal.y / normal.x);
        tilt.y = tilt.x * normal.y / normal.x;
    }
    else if (abs(normal.y) > 0.0) {
        tilt.y = (focus_a.z - focus_b.z) * focal_length / (focus_a.z * focus_b.y - focus_b.z * focus_a.y + (focus_a.z * focus_b.x - focus_b.z * focus_a.x) * normal.x / normal.y);
        tilt.x = tilt.y * normal.x / normal.y;
    }

    tilt.z = sqrt(1.0 - tilt.x * tilt.x - tilt.y * tilt.y);

    float3 basis_u = normalize(cross(tilt, abs(tilt.x) > abs(tilt.y) ? float3(0.0, 1.0, 0.0) : float3(1.0, 0.0, 0.0)));
    float3 basis_v = cross(tilt, basis_u);
    float aperture = focal_length / f_stop;
    
    // Image plane values (precomputable)
    float image_plane = focus_a.z * focal_length / (dot(focus_a, tilt) - focal_length);
    float2 shift = middle.xy / middle.z * -image_plane;

    // Image plane values (render-time)
    float3 sensor = float3(screen * 0.5 * sensor_size + shift, -image_plane);
    
    // Lens values (render-time)
    float theta = 6.28318531 * random.x;
    float r = 0.5 * aperture * sqrt(random.y);
    float3 lens = (cos(theta) * basis_u + sin(theta) * basis_v) * r;
    
    // Focal plane values (render-time)
    float3 focused = sensor * focal_length / (focal_length + dot(sensor, tilt));
    float flip = sign(dot(tilt, focused));

    ray_origin = lens;
    ray_direction = flip * normalize(focused - lens);
}

int sphere(
    float3 origin,
    float3 direction,
    float3 center,
    float radius,
    inout float t,
    inout float3 hit,
    inout float3 normal)
{
    float3 offset = origin - center;
    float b = dot(offset, direction);
    float c = dot(offset, offset) - radius * radius;
    float discriminant = b * b - c;

    if (discriminant <= 0.0)
        return 0;

    float t_sphere = -b - sqrt(discriminant);

    if (t_sphere < epsilon || t < t_sphere)
        return 0;

    t = t_sphere;
    hit = origin + direction * t;
    normal = normalize(hit - center);
    return 1;
}

float3 rng(float3 seed)
{
    uint3 v = uint3(abs(seed) * 1048576.0);
    v = v * 1664525u + 1013904223u;
    v.x += v.y * v.z;
    v.y += v.z * v.x;
    v.z += v.x * v.y;
    v ^= v >> 16u;
    v.x += v.y*v.z;
    v.y += v.z*v.x;
    v.z += v.x*v.y;
    return float3(v) * (1.0 / float(0xffffffffu));
}

int trace(
    float3 origin,
    float3 direction,
    float t,
    out float3 hit,
    out float3 normal,
    out float3 diffuse,
    out float3 specular,
    out float3 emissive)
{
    float3 x_axis = float3(1.0, 0.0, 0.0);
    float3 y_axis = float3(0.0, 1.0, 0.0);
    float3 z_axis = float3(0.0, 0.0, 1.0);

    float original_t = t;

    if (sphere(origin, direction, red_sphere, 0.1, t, hit, normal) > 0)
    {
        diffuse  = float3(1.0, 0.1, 0.1);
        specular = float3(0.9, 0.4, 0.4);
        emissive = float3(0.0, 0.0, 0.0);
    }

    if (sphere(origin, direction, green_sphere, 0.1, t, hit, normal) > 0)
    {
        diffuse  = float3(0.1, 1.0, 0.1);
        specular = float3(0.4, 0.9, 0.4);
        emissive = float3(0.0, 0.0, 0.0);
    }

    if (sphere(origin, direction, blue_sphere, 0.1, t, hit, normal) > 0)
    {
        diffuse  = float3(0.1, 0.1, 1.0);
        specular = float3(0.4, 0.4, 0.9);
        emissive = float3(0.0, 0.0, 0.0);
    }

    return original_t == t ? 0 : 1;
}

float3 shade(
    inout float3 origin,
    inout float3 direction)
{
    float3 shaded     = float3(0.0, 0.0, 0.0);
    float3 throughput = float3(1.0, 1.0, 1.0);
    for (int bounce = 0; bounce < 3; ++bounce)
    {
        float t = 1.0e30;
        float3 hit      = float3(0.0, 0.0, 0.0);
        float3 normal   = float3(0.0, 0.0, 0.0);
        float3 diffuse  = float3(0.0, 0.0, 0.0);
        float3 specular = float3(0.0, 0.0, 0.0);
        float3 emissive = float3(0.0, 0.0, 0.0);
        trace(origin, direction, t, hit, normal, diffuse, specular, emissive);

        // Add in emissive contribution.

        shaded += throughput * emissive;

        // Add in direct lighting via next event estimation.

        float3 xi_1 = rng(hit);
        float3 light = float3((xi_1.x - 0.5) * 0.1, 0.99, (xi_1.z - 0.5) * 0.1);
        float3 light_direction = light - hit;

        if (dot(normal, light_direction) > 0.0)
        {
            float light_distance = length(light_direction);
            light_direction /= light_distance;
            float3 shadow_hit      = float3(0.0, 0.0, 0.0);
            float3 shadow_normal   = float3(0.0, 0.0, 0.0);
            float3 shadow_diffuse  = float3(0.0, 0.0, 0.0);
            float3 shadow_specular = float3(0.0, 0.0, 0.0);
            float3 shadow_emissive = float3(0.0, 0.0, 0.0);
            int intersected = trace(hit, light_direction, light_distance,
                                    shadow_hit, shadow_normal,
                                    shadow_diffuse, shadow_specular, shadow_emissive);
            if (intersected == 0)
            {
                float3 halfway = normalize(light_direction + normalize(origin - hit));
                float lambert = max(0.0, dot(normal, light_direction));
                float blinn_phong = 3.0 * pow(max(0.0, dot(halfway, normal)), 64.0);
                shaded += throughput * (diffuse * lambert + specular * blinn_phong);
            }
        }

        // Update for indirect lighting: adjust path throughput
        // and choose new ray for next path segment.

        float diffuse_weight = dot(diffuse, float3(1.0, 1.0, 1.0));
        float specular_weight = dot(specular, float3(1.0, 1.0, 1.0));
        if (xi_1.y * (diffuse_weight + specular_weight) <= diffuse_weight)
        {
            float3 xi_2 = rng(hit + float3(239.0, 491.0, 128.0));
            float phi = 6.28318531 * xi_2.x;
            float cos_theta_sq = xi_2.y;
            float sin_theta = sqrt(1.0 - cos_theta_sq);
            float sgn = normal.z < 0.0 ? -1.0 : 1.0;
            float a = -1.0 / (sgn + normal.z);
            float b = normal.x * normal.y * a;
            direction =
                (float3(b, sgn + normal.y * normal.y * a, -normal.y) * (cos(phi) * sin_theta) +
                 float3(1.0 + sgn * normal.x * normal.x * a, sgn * b, -sgn * normal.x) * (sin(phi) * sin_theta) +
                 normal * sqrt(cos_theta_sq));
            throughput *= diffuse;
        }
        else
        {
            direction = reflect(direction, normal);
            throughput *= specular;
        }

        origin = hit + direction * 0.001;
    }
    return shaded;
}

float3 Shade(inout Ray ray, RayHit hit)
{
    if (hit.distance < 1.#INF)
    {
        // Return the normal
        return hit.normal * 0.5f + 0.5f;
    }
    else
    {
        // Sample the skybox and write it
        float theta = acos(ray.direction.y) / -PI;
        float phi = atan2(ray.direction.x, -ray.direction.z) / -PI * 0.5f;
        return _SkyboxTexture.SampleLevel(sampler_SkyboxTexture, float2(phi, theta), 0).xyz;
    }
}

void IntersectSphere(Ray ray, inout RayHit bestHit, float4 sphere)
{
    // Calculate distance along the ray where the sphere is intersected
    float3 d = ray.origin - sphere.xyz;
    float p1 = -dot(ray.direction, d);
    float p2sqr = p1 * p1 - dot(d, d) + sphere.w * sphere.w;

    if (p2sqr < 0)
        return;

    float p2 = sqrt(p2sqr);
    float t = p1 - p2 > 0 ? p1 - p2 : p1 + p2;

    if (t > 0 && t < bestHit.distance)
    {
        bestHit.distance = t;
        bestHit.position = ray.origin + t * ray.direction;
        bestHit.normal = normalize(bestHit.position - sphere.xyz);
    }
}

RayHit Trace(Ray ray) {
    RayHit bestHit = CreateRayHit();

    // Add a floating unit sphere
    IntersectSphere(ray, bestHit, float4(blue_sphere.xyz, 0.2));
    IntersectSphere(ray, bestHit, float4(green_sphere.xyz, 0.2));
    IntersectSphere(ray, bestHit, float4(red_sphere.xyz,  0.2));

    return bestHit;
}

Ray CreateRay(float3 origin, float3 direction)
{
    Ray ray;
    ray.origin = origin;
    ray.direction = direction;
    return ray;
}

Ray CreateCameraRay(float2 uv)
{
    float3 origin = eye;
    float3 direction = normalize(look_at - eye);
    return CreateRay(origin, direction);
}

[numthreads(8,8,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    // Get the dimensions of the RenderTexture
    uint width, height;
    Result.GetDimensions(width, height);
    // Transform pixel to [-1,1] range
    float2 uv = float2((id.xy + float2(0.5f, 0.5f)) / float2(width, height) * 2.0f - 1.0f);
    // Get a ray for the UVs
    Ray ray = CreateCameraRay(uv);

    // Trace and shade
    RayHit hit = Trace(ray);
    float3 result = Shade(ray, hit);
    Result[id.xy] = float4(result, 1);

    // uint width, height;
    // Result.GetDimensions(width, height);
    
    // float3 gaze  = normalize(look_at - eye);
    // float3 right = normalize(cross(gaze, float3(0.0, 1.0, 0.0)));
    // float3 up    = cross(gaze, right);

    // // float2 jittered = id.xy + rng(float3(id.xy, _FrameCount)).xy;
    // // float2 screen = (2.0 * jittered - float2(width, height)) / min(width, height);
    // float2 screen = (2.0 * jittered - float2(width, height)) / min(width, height);
    // float2 random = rng(float3(screen, _FrameCount)).xy;

    // float3 origin, direction;
    // // CAMERA(screen, random, origin, direction);
    // tilt_shift(screen, random, origin, direction);
    // origin = eye + origin.x * right + origin.y * up + origin.z * gaze;
    // direction = normalize(direction.x * right + direction.y * up + direction.z * gaze);

    // Result[id.xy] = float4(shade(origin, direction), 1.0);

    // float2 uv = (id.xy + 0.5) / float2(width, height);    // [0..1]
    // uv = uv * 2.0 - 1.0;                                  // [-1..1]
    // float aspect = (float)width / (float)height;
    // uv.x *= aspect;

    // // Hard-code a pinhole ray
    // float3 origin = eye;
    // float3 direction = look_at - eye;
    // // float3 direction = normalize( float3(uv, 1.0) );

    // // Or if your camera is supposed to look along +Z in local space:
    // // direction = normalize( float3(uv.x, uv.y, +1.0) );

    // Result[id.xy] = float4(shade(origin, direction), 1.0);

}